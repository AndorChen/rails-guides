[[action-view-overview]]
== Action View 概述
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
读完本文后，你将学会：

* Action View 是什么，如何在 Rails 中使用 Action View。
* 模板、局部视图和布局的最佳使用方法。
* Action View 提供了哪些帮助方法，如何编写自己的帮助方法。
* 如何使用本地化视图。
--

[[what-is-action-view]]
=== Action View 是什么

在Rails中，Web 请求由 Action Controller（请参阅 <<action_controller_overview>>）和 Action View 处理。通常，Action Controller 参与和数据库的通信，并在需要时执行 CRUD 操作，然后由 Action View 负责编译响应。

Action View 模板使用混合了 HTML 标签的嵌入式 Ruby 语言编写。为了避免样板代码把模板弄乱，Action View 提供了许多帮助方法，用于创建表单、日期和字符串等常用组件。随着开发的深入，为程序添加新的帮助方法也很容易。

NOTE: Action View 的某些特性与 Active Record 有关，但这并不意味着 Action View 依赖 Active Record。Action View 是独立的软件包，可以和任何类型的 Ruby 库一起使用。

[[using-action-view-with-rails]]
=== 在 Rails 中使用 Action View

在 `app/views` 文件夹中，每个控制器都有一个对应的文件夹，其中保存了控制器对应视图的模板文件。这些模板文件用于显示每个控制器动作产生的视图。

在 Rails 中使用脚手架生成器来新建资源时，默认会执行下面的操作：

----
$ bin/rails generate scaffold article
      [...]
      invoke  scaffold_controller
      create    app/controllers/articles_controller.rb
      invoke    erb
      create      app/views/articles
      create      app/views/articles/index.html.erb
      create      app/views/articles/edit.html.erb
      create      app/views/articles/show.html.erb
      create      app/views/articles/new.html.erb
      create      app/views/articles/_form.html.erb
      [...]
----

在上面的输出结果中我们可以看到 Rails 中视图的命名约定。通常，视图和对应的控制器动作共享名称。例如，`articles_controller.rb` 控制器文件中的 `index` 动作对应 `app/views/articles` 文件夹中的 `index.html.erb` 视图文件。返回客户端的完整 HTML 由 ERB 视图文件和包装它的布局文件，以及视图可能引用的所有局部视图文件组成。后文会详细介绍这三种文件。

[[templates-partials-and-layouts]]
=== 模板、局部视图和布局

前面说过，最后输出的 HTML 由模板、局部视图和布局这三种 Rails 元素组成。下面分别进行简要介绍。

[[templates]]
==== 模板

Action View 模板可以用多种方式编写。扩展名是 `.erb` 的模板文件混合使用 ERB（嵌入式 Ruby）和 HTML 编写，扩展名是 `.builder` 的模板文件使用 `Builder::XmlMarkup` 库编写。

Rails 支持多种模板系统，并使用文件扩展名加以区分。例如，使用 ERB 模板系统的 HTML 文件的扩展名是 `.html.erb`。

[[erb]]
===== ERB 模板

在 ERB 模板中，可以使用 `<% %>` 和 `<%= %>` 标签来包含 Ruby 代码。`<% %>` 标签用于执行不返回任何内容的 Ruby 代码，例如条件、循环或块，而 `<%= %>` 标签用于输出 Ruby 代码的执行结果。

下面是一个循环输出名称的例子：

[source,irb]
----
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
<% end %>
----

在上面的代码中，使用普通嵌入标签（`<% %>`）建立循环，使用输出嵌入标签（`<%= %>`）插入名称。请注意，这种用法不仅仅是建议用法（而是必须这样使用），因为在 ERB 模板中，普通的输出方法，例如 `print` 和 `puts` 方法，无法正常渲染。因此，下面的代码是错误的：

[source,irb]
----
<%# WRONG %>
Hi, Mr. <% puts "Frodo" %>
----

要想删除前导和结尾空格，可以把 `<% %>` 标签替换为 `<%- -%>` 标签。

[[builder]]
===== Builder 模板

和 ERB 模板相比，Builder 模板更加按部就班，常用于生成 XML 内容。在扩展名为 `.builder` 的模板中，可以直接使用名为 `xml` 的 XmlMarkup 对象。

下面是一些简单的例子：

[source,ruby]
----
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "http://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
----

上面的代码会生成下面的 XML：

[source,xml]
----
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="http://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
----

带有块的方法会作为 XML 标签处理，块中的内容会嵌入这个标签中。例如：

[source,ruby]
----
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
----

上面的代码会生成下面的 XML：

[source,xml]
----
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
----

下面是 Basecamp 网站用于生成 RSS 的完整的实际代码：

[source,ruby]
----
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
----

[[jbuilder]]
===== Jbuilder 模板系统

link:https://github.com/rails/jbuilder[Jbuilder] 是由 Rails 团队维护并默认包含在 Rails Gemfile 中的 gem。它类似 Builder，但用于生成 JSON，而不是 XML。

如果你的程序中没有 Jbuilder 这个 gem，可以把下面的代码添加到 Gemfile：

[source,ruby]
----
gem 'jbuilder'
----

在扩展名为 `.jbuilder` 的模板中，可以直接使用名为 `json` 的 Jbuilder 对象。

下面是一个简单的例子：

[source,ruby]
----
json.name("Alex")
json.email("alex@example.com")
----

上面的代码会生成下面的 JSON：

[source,json]
----
{
  "name": "Alex",
  "email": "alex@example.com"
}
----

关于 Jbuilder 模板的更多例子和信息，请参阅 link:https://github.com/rails/jbuilder#jbuilder[Jbuilder 文档]。

[[template-caching]]
===== 模板缓存

默认情况下，Rails 会把所有模板分别编译为方法，以便进行渲染。在开发环境中，当我们修改了模板时，Rails 会检查文件的修改时间并自动重新编译。

[[partials]]
==== 局部视图

局部视图模板，通常直接称为“局部视图”，会把渲染过程分成多个更容易管理的部分。局部视图从模板中提取代码片断并保存在独立的文件中，然后在模板中重用这些代码片断。

[[naming-partials]]
===== 局部视图的名称

在视图中我们使用 `render` 方法来渲染局部视图：

[source,erb]
----
<%= render "menu" %>
----

在渲染视图的过程中，上面的代码会渲染 `_menu.html.erb` 局部视图文件。请注意前导的下划线：局部视图的文件名总是以下划线开头，以便和普通视图文件区分开来，但在引用局部视图时不写下划线。从其他文件夹中加载局部视图文件时同样遵守这一规则：

[source,erb]
----
<%= render "shared/menu" %>
----

上面的代码会加载 `app/views/shared/_menu.html.erb` 局部视图文件。

[[using-partials-to-simplify-views]]
===== 使用局部视图来简化视图

使用局部视图的一种方式是把它们看作子程序，也就是把细节内容从视图中移出来，这样会使视图更容易理解。例如：

[source,erb]
----
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>

<%= render "shared/footer" %>
----

在上面的代码中，`_ad_banner.html.erb` 和 `_footer.html.erb` 局部视图可以在多个页面中使用。当我们专注于实现某个页面时，不必关心这些局部视图的细节。

[[render-without-partial-and-locals-options]]
===== 不使用 `partial` 和 `locals` 选项进行渲染

在前面的例子中，`render` 方法有两个选项：`partial` 和 `locals`。如果一共只有这两个选项，那么可以跳过不写。例如，下面的代码：

[source,erb]
----
<%= render partial: "product", locals: { product: @product } %>
----

可以改写为：

[source,erb]
----
<%= render "product", product: @product %>
----

[[the-as-and-object-options]]
===== `as` 和 `object` 选项

默认情况下，`ActionView::Partials::PartialRenderer` 的对象储存在和模板同名的局部变量中。因此，我们可以扩展下面的代码：

[source,erb]
----
<%= render partial: "product" %>
----

在 `_product` 局部视图中，我们可以通过局部变量 `product` 引用 `@product` 实例变量：

[source,erb]
----
<%= render partial: "product", locals: { product: @product } %>
----

`as` 选项用于为局部变量指定不同的名称。例如，把局部变量的名称由 `product` 改为 `item`：

[source,erb]
----
<%= render partial: "product", as: "item" %>
----

`object` 选项用于直接指定想要在局部视图中使用的对象，常用于模板对象位于其他地方（例如位于其他实例变量或局部变量中）的情况。例如，下面的代码：

[source,erb]
----
<%= render partial: "product", locals: { product: @item } %>
----

可以改写为：

[source,erb]
----
<%= render partial: "product", object: @item %>
----

`object` 和 `as` 选项还可一起使用：

[source,erb]
----
<%= render partial: "product", object: @item, as: "item" %>
----

[[rendering-collections]]
===== 集合的渲染

模板经常需要遍历集合并使用集合的每个元素分别渲染子模板。在 Rails 中我们只需一行代码就可以完成这项工作。例如，下面这段渲染产品局部视图的代码：

[source,erb]
----
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>
----

可以改写为：

[source,erb]
----
<%= render partial: "product", collection: @products %>
----

当使用集合来渲染局部视图时，在每个局部视图实例中，都可以使用和局部视图同名的局部变量来访问集合中的元素。在本例中，局部视图是 `_product`，在这个局部视图中我们可以通过 `product` 局部变量来访问用于渲染局部视图的集合中的元素。

渲染集合还有一个简易写法。假设 `@products` 是 `Product` 的实例的集合，上面的代码可以改写为：

[source,erb]
----
<%= render @products %>
----

Rails 会根据集合中的模型名来确定应该使用哪个局部视图，在本例中模型名是 `Product`。实际上，我们甚至可以使用这种简易写法来渲染由不同模型实例组成的集合，Rails 会为集合中的每个元素选择适当的局部视图。

[[spacer-templates]]
===== 间隔模板

我们还可以使用 `:spacer_template` 选项来指定第二个局部视图（也就是间隔模板），在渲染第一个局部视图（也就是主局部视图）的两个实例之间会渲染这个间隔模板:

[source,erb]
----
<%= render partial: @products, spacer_template: "product_ruler" %>
----

上面的代码会在两个 `_product` 局部视图（主局部视图）之间渲染 `_product_ruler` 局部视图（间隔模板）。

[[layouts]]
==== 布局

布局是渲染 Rails 控制器返回结果时使用的公共视图模板。通常，Rails 程序中会包含多个视图用于渲染不同页面。例如，网站中用户登录后页面的布局，营销或销售页面的布局。用户登录后页面的布局可以包含在多个控制器动作中出现的顶级导航。SaaS 程序的销售页面布局可以包含指向“定价”和“联系我们”页面的顶级导航。不同布局可以有不同的外观和感觉。关于布局的更多介绍，请参阅 <<layouts_and_rendering>> 一文。

[[partial-layout]]
=== 局部布局

应用于局部视图的布局称为局部布局。局部布局和应用于控制器动作的全局布局不一样，但两者的工作方式类似。

比如说我们想在页面上显示文章，并使用 `div` 标签包装文章。首先，我们新建一个 `Article` 的实例：

[source,ruby]
----
Article.create(body: 'Partial Layouts are cool!')
----

在 `show` 模板中，我们要在 `box` 布局中渲染 `_article` 局部视图：

`articles/show.html.erb`

[source,erb]
----
<%= render partial: 'article', layout: 'box', locals: { article: @article } %>
----

`box` 布局只是把 `_article` 局部视图包装在 `div` 标签中：

`articles/_box.html.erb`

[source,erb]
----
<div class='box'>
  <%= yield %>
</div>
----

请注意，局部布局可以访问传递给 `render` 方法的 `article` 本地变量。不过，和全局部局不同，局部布局的文件名使用下划线前缀。

我们还可以直接渲染代码块而不调用 `yield` 方法。例如，如果不使用 `_article` 局部视图，我们可以像下面这样编写代码：

**`articles/show.html.erb`**

[source,erb]
----
<% render(layout: 'box', locals: { article: @article }) do %>
  <div>
    <p><%= article.body %></p>
  </div>
<% end %>
----

假设我们使用的 `_box` 局部布局和前面例子一样，那么本例中模板的渲染结果也会和前面的例子一样。

[[view-paths]]
=== 视图路径

在渲染响应时，控制器需要解析不同视图所在的位置。默认情况下，控制器只查找 `app/views` 文件夹。

我们可以使用 `prepend_view_path` 和 `append_view_path` 方法分别在查找路径的开头和结尾添加其他位置。

[[prepend-view-path]]
==== 在开头添加视图路径

例如，当需要把视图放在子域名的不同文件夹中时，我们可以使用下面的代码：

[source,ruby]
----
prepend_view_path "app/views/#{request.subdomain}"
----

这样在解析视图时，Action View 会首先查找这个文件夹。

[[append-view-path]]
==== 在末尾添加视图路径

同样，我们可以在查找路径的末尾添加视图路径：

[source,ruby]
----
append_view_path "app/views/direct"
----

上面的代码会在查找路径的末尾添加 `app/views/direct` 文件夹。

[[overview-of-helpers-provided-by-action-view]]
=== Action View 提供的帮助方法概述

NOTE: 本节内容仍在完善中，目前并没有列出所有帮助方法。关于帮助方法的完整列表，请参阅 link:http://api.rubyonrails.org/classes/ActionView/Helpers.html[API文档]。

本节内容只是对 Action View 中可用帮助方法的简要概述。在阅读本节内容之后，推荐查看 link:http://api.rubyonrails.org/classes/ActionView/Helpers.html[API文档]，该文档详细介绍了所有帮助方法。

[[assettaghelper]]
==== `AssetTagHelper` 模块

`AssetTagHelper` 模块提供的方法用于生成链接静态资源文件的 HTML 代码，例如链接图片、JavaScript 文件和订阅的 HTML 代码。

默认情况下，Rails 会链接当前主机 `public` 文件夹中的静态资源文件。要想链接专用的静态资源文件服务器上的文件，可以设置 Rails 程序配置文件（通常是 `config/environments/production.rb` 文件）中的 `config.action_controller.asset_host` 选项。例如，假设静态资源文件服务器的域名是 `assets.example.com`，我们可以像下面这样进行设置：

[source,ruby]
----
config.action_controller.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" alt="Rails" />
----

[[auto-discovery-link-tag]]
===== `auto_discovery_link_tag` 方法

`auto_discovery_link_tag` 方法用于返回链接标签，使浏览器和订阅阅读器可以自动检测 RSS 或 Atom 订阅。

[source,ruby]
----
auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", { title: "RSS Feed" }) # =>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.example.com/feed.rss" />
----

[[image-path]]
===== `image_path` 方法

`image_path` 方法用于计算 `app/assets/images` 文件夹中图片资源的路径，得到的路径是从根目录开始的完整路径（也就是绝对路径）。`image_tag` 方法在内部使用 `image_path` 方法生成图片标签。

[source,ruby]
----
image_path("edit.png") # => /assets/edit.png
----
当 `config.assets.digest` 选项设置为 `true` 时，Rails 会为图片资源的文件名添加指纹。

[source,ruby]
----
image_path("edit.png") # => /assets/edit-2d1a2db63fc738690021fedb5a65b68e.png
----

[[image-url]]
===== `image_url` 方法

`image_url` 方法用于计算 `app/assets/images` 文件夹中图片资源的 URL 地址。`image_url` 方法在内部调用了 `image_path` 方法，并把得到的图片资源路径和当前主机或静态资源文件服务器的 URL 地址合并。

[source,ruby]
----
image_url("edit.png") # => http://www.example.com/assets/edit.png
----

[[image-tag]]
===== `image_tag` 方法

`image_tag` 方法用于返回 HTML 图片标签。此方法接受图片的完整路径或 `app/assets/images` 文件夹中图片的文件名作为参数。

[source,ruby]
----
image_tag("icon.png") # => <img src="/assets/icon.png" alt="Icon" />
----

[[javascript-include-tag]]
===== `javascript_include_tag` 方法

`javascript_include_tag` 方法用于返回 HTML 脚本标签。此方法接受 `app/assets/javascripts` 文件夹中 JavaScript 文件的文件名（`.js` 后缀可以省略）或 JavaScript 文件的完整路径（绝对路径）作为参数。

[source,ruby]
----
javascript_include_tag "common" # => <script src="/assets/common.js"></script>
----

如果 Rails 程序不使用 Asset Pipeline，就需要向 `javascript_include_tag` 方法传递 `:defaults` 参数来包含 jQuery JavaScript 库。此时，如果 `app/assets/javascripts` 文件夹中存在 `application.js` 文件，那么这个文件也会包含到页面中。

[source,ruby]
----
javascript_include_tag :defaults
----

通过向 `javascript_include_tag` 方法传递 `:all` 参数，可以把 `app/assets/javascripts` 文件夹下的所有 JavaScript 文件包含到页面中。

[source,ruby]
----
javascript_include_tag :all
----

我们还可以把多个 JavaScript 文件缓存为一个文件，这样可以减少下载时的 HTTP 连接数，同时还可以启用 gzip 压缩来提高传输速度。当 `ActionController::Base.perform_caching` 选项设置为 `true` 时才会启用缓存，此选项在生产环境下默认为 `true`，在开发环境下默认为 `false`。

[source,ruby]
----
javascript_include_tag :all, cache: true # =>
  <script src="/javascripts/all.js"></script>
----

[[javascript-path]]
===== `javascript_path` 方法

`javascript_path` 方法用于计算 `app/assets/javascripts` 文件夹中 JavaScript 资源的路径。如果没有指定文件的扩展名，Rails 会自动添加 `.js` 扩展名。`javascript_path` 方法返回 JavaScript 资源的完整路径（绝对路径）。`javascript_include_tag` 方法在内部使用 `javascript_path` 方法生成脚本标签。

[source,ruby]
----
javascript_path "common" # => /assets/common.js
----

[[javascript-url]]
===== `javascript_url` 方法

`javascript_url` 方法用于计算 `app/assets/javascripts` 文件夹中 JavaScript 资源的 URL 地址。`javascript_url` 方法在内部调用了 `javascript_path` 方法，并把得到的 JavaScript 资源的路径和当前主机或静态资源文件服务器的 URL 地址合并。

[source,ruby]
----
javascript_url "common" # => http://www.example.com/assets/common.js
----

[[stylesheet-link-tag]]
===== `stylesheet_link_tag` 方法

`stylesheet_link_tag` 方法用于返回样式表链接标签。如果没有指定文件的扩展名，Rails 会自动添加 `.css` 扩展名。

[source,ruby]
----
stylesheet_link_tag "application" # => <link href="/assets/application.css" media="screen" rel="stylesheet" />
----

通过向 `stylesheet_link_tag` 方法传递 `:all` 参数，可以把样式表文件夹中的所有样式表包含到页面中。

[source,ruby]
----
stylesheet_link_tag :all
----

我们还可以把多个样式表缓存为一个文件，这样可以减少下载时的 HTTP 连接数，同时还可以启用 gzip 压缩来提高传输速度。当 `ActionController::Base.perform_caching` 选项设置为 `true` 时才会启用缓存，此选项在生产环境下默认为 `true`，在开发环境下默认为 `false`。

[source,ruby]
----
stylesheet_link_tag :all, cache: true
# => <link href="/assets/all.css" media="screen" rel="stylesheet" />
----

[[stylesheet-path]]
===== `stylesheet_path` 方法

`stylesheet_path` 方法用于计算 `app/assets/stylesheets` 文件夹中样式表资源的路径。如果没有指定文件的扩展名，Rails 会自动添加 `.css` 扩展名。`stylesheet_path` 方法返回样式表资源的完整路径（绝对路径）。`stylesheet_link_tag` 方法在内部使用 `stylesheet_path` 方法生成样式表链接标签。

[source,ruby]
----
stylesheet_path "application" # => /assets/application.css
----

[[stylesheet-url]]
===== `stylesheet_url` 方法

`stylesheet_url` 方法用于计算 `app/assets/stylesheets` 文件夹中样式表资源的 URL 地址。`stylesheet_url` 方法在内部调用了 `stylesheet_path` 方法，并把得到的样式表资源路径和当前主机或静态资源文件服务器的 URL 地址合并。

[source,ruby]
----
stylesheet_url "application" # => http://www.example.com/assets/application.css
----

[[atomfeedhelper]]
==== `AtomFeedHelper` 模块

[[atom-feed]]
===== `atom_feed` 方法

通过 `atom_feed` 帮助方法我们可以轻松创建 Atom 订阅。下面是一个完整的示例：

`config/routes.rb`

[source,ruby]
----
resources :articles
----

`app/controllers/articles_controller.rb`

[source,ruby]
----
def index
  @articles = Article.all

  respond_to do |format|
    format.html
    format.atom
  end
end
----

`app/views/articles/index.atom.builder`

[source,ruby]
----
atom_feed do |feed|
  feed.title("Articles Index")
  feed.updated(@articles.first.created_at)

  @articles.each do |article|
    feed.entry(article) do |entry|
      entry.title(article.title)
      entry.content(article.body, type: 'html')

      entry.author do |author|
        author.name(article.author_name)
      end
    end
  end
end
----

[[benchmarkhelper]]
==== `BenchmarkHelper` 模块
