[[the-asset-pipeline]]
== Asset Pipeline
:imagesdir: ../images
:numbered:

// chinakr 翻译

[.chapter-abstract]
--
本文介绍 Asset Pipeline。

读完本文后，您将学到：

* Asset Pipeline 是什么，有什么用处；
* 如何合理组织程序的静态资源文件；
* 使用 Asset Pipeline 的好处；
* 如何为 Asset Pipeline 添加预处理器；
* 如何用 gem 打包静态资源文件。
--

[[what-is-the-asset-pipeline]]
=== Asset Pipeline 是什么

Asset Pipeline 提供了用于连接、缩小或压缩 JavaScript 和 CSS 静态资源文件的框架。有了 Asset Pipeline，我们还可以使用其他语言和预处理器，例如 CoffeeScript、Sass 和 ERB，编写这些静态资源文件。应用中的静态资源文件还可以自动和其他 gem 中的静态资源文件合并。例如，和 `jquery-rails` gem 中包含的 `jquery.js` 文件合并，从而使 Rails 能够支持 AJAX 特性。

Asset Pipeline 是通过 link:$$https://github.com/rails/sprockets-rails$$[sprockets-rails] gem 实现的，Rails 默认启用了这个 gem。在新建 Rails 应用时，通过 `--skip-sprockets` 选项可以禁用这个 gem。

[source,shell]
----
rails new appname --skip-sprockets
----

在新建 Rails 应用时，Rails 自动在 Gemfile 中添加了 `sass-rails`、`coffee-rails` 和 `uglifier` gem，Sprockets 通过这些 gem 来压缩静态资源文件：

[source,ruby]
----
gem 'sass-rails'
gem 'uglifier'
gem 'coffee-rails'
----

使用 `--skip-sprockets` 选项时，Rails 不会在 Gemfile 中添加这些 gem。因此，之后如果想要启用 Asset Pipeline，就需要手动在 Gemfile 中添加这些 gem。此外，使用 `--skip-sprockets` 选项时生成的 `config/application.rb` 也略有不同，用于加载 `sprockets/railtie` 的代码被注释掉了，因此要启用 Asset Pipeline，还需要取消注释：

[source,ruby]
----
# require "sprockets/railtie"
----

在 `production.rb` 配置文件中，通过 `config.assets.css_compressor` 和 `config.assets.js_compressor` 选项可以分别为 CSS 和 JavaScript 静态资源文件设置压缩方式：

[source,ruby]
----
config.assets.css_compressor = :yui
config.assets.js_compressor = :uglifier
----

NOTE: 如果 Gemfile 中包含了 `sass-rails` gem，Rails 就会自动使用这个 gem 压缩 CSS 静态资源文件，而无需设置 `config.assets.css_compressor` 选项。

[[main-features]]
==== 主要特性

Asset Pipeline 的特性之一是连接静态资源文件，目的是减少渲染网页时浏览器发起的请求次数。Web 浏览器能够同时发起的请求次数是有限的，因此更少的请求次数可能意味着更快的应用加载速度。

Sprockets 把所有 JavaScript 文件连接为一个主 `.js` 文件，把所有 CSS文 件连接为一个主 `.css` 文件。后文会介绍，我们可以按需定制连接文件的方式。在生产环境中，Rails 会在每个文件名中插入 MD5 指纹，以便 Web 浏览器缓存文件。当我们修改了文件内容，Rails 会自动修改文件名中的指纹，从而让原有缓存失效。

Asset Pipeline 的特性之二是缩小或压缩静态资源文件。对于 CSS 文件，会删除空格和注释。对于 JavaScript 文件，可以进行更复杂的处理，我们可以从内置选项中选择处理方式，也可以自定义处理方式。

Asset Pipeline 的特性之三是可以使用更高级的语言编写静态资源文件，再通过预编译转换为实际的静态资源文件。默认支持的高级语言有：用于编写 CSS 的 Sass，用于编写 JavaScript 的 CoffeeScript，以及 ERB。

[[what-is-fingerprinting-and-why-should-i-care]]
==== 指纹识别是什么，为什么要关心指纹？

指纹是一项根据文件内容修改文件名的技术。一旦文件内容发生变化，文件名就会发生变化。对于静态文件或内容很少发生变化的文件，这项技术提供了确定文件的两个版本是否相同的简单方法，特别是在跨服务器和多次部署的情况下。

当一个文件的文件名能够根据文件内容发生变化，并且能够保证不会出现重名时，就可以通过设置 HTTP 请求头来建议所有缓存（CDN、ISP、网络设备或 Web 浏览器的缓存）都保存该文件的副本。一旦文件内容更新，文件名中的指纹就会发生变化，从而使远程客户端发起对文件新副本的请求。这项技术被称为“缓存清除”（cache busting）。

Sprockets 使用指纹的方式是在文件名中添加文件内容的哈希值，并且通常会添加到文件名末尾。例如，对于 CSS 文件 `global.css`，添加哈希值后文件名可能变为：

----
global-908e25f4bf641868d8683022a5b62f54.css
----

Rails 的 Asset Pipeline 也采取了这种策略。

以前 Rails 采用的策略是，通过内置的辅助方法，为每一个指向静态资源文件的链接，添加基于日期生成的查询字符串。在网页源代码中，会生成下面这样的链接：

----
/stylesheets/global.css?1309495796
----

使用查询字符串的策略有如下缺点：

1.如果一个文件的两个版本只是文件名的查询参数不同，这时不是所有缓存都能可靠地更新该文件的缓存。::
  link:$$http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/$$[Steve Souders] 建议，“……避免在可缓存的资源上使用查询字符串”。他发现，在使用查询字符串的情况下，有 5—20% 的请求不会被缓存。对于某些 CDN，通过修改查询字符串根本无法使缓存失效。

2.在多服务器环境中，不同节点上的文件名有可能发生变化。::
  在 Rails 2.x 中，默认基于文件修改时间生成查询字符串。当静态资源文件被部署到某个节点上时，无法保证文件的时间戳保持不变，这样，对于同一个文件的请求，不同服务器可能返回不同的文件名。

3.缓存失效的情况过多。::
  每次部署代码的新版本时，静态资源文件都会被重新部署，这些文件的最后修改时间也会发生变化。这样，不管其内容是否发生变化，客户端都不得不重新获取这些文件。

使用指纹可以避免使用查询字符串的这些缺点，并且能够确保文件内容相同时文件名也相同。

在开发环境和生产环境中，指纹都是默认启用的。通过 `config.assets.digest` 配置选项，可以启用或禁用指纹。

扩展阅读：

* link:$$http://code.google.com/speed/page-speed/docs/caching.html$$[优化缓存]
* link:$$http://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/$$[为文件名添加版本号：请不要使用查询字符串]

[[how-to-use-the-asset-pipeline]]
=== 如何使用 Asset Pipeline

在 Rails 的早期版本中，所有静态资源文件都放在 `public` 文件夹的子文件夹中，例如 `images`、`javascripts` 和 `stylesheets` 子文件夹。当 Rails 开始使用 Asset Pipeline 后，就推荐把静态资源文件放在 `app/assets` 文件夹中，并使用 Sprockets 中间件处理这些文件。

当然，静态资源文件仍然可以放在 `public` 文件夹及其子文件夹中。只要把 `config.public_file_server.enabled` 选项设置为 `true`，Rails 应用或 Web 服务器就会处理 `public` 文件夹及其子文件夹中的所有静态资源文件。但对于需要预处理的文件，都应该放在 `app/assets` 文件夹中。

在生产环境中，Rails 默认会对 `public/assets` 文件夹中的文件进行预处理。经过预处理的静态资源文件将由 Web 服务器直接处理。在生产环境中，`app/assets` 文件夹中的文件不会直接交由 Web 服务器处理。

[[controller-specific-assets]]
==== 针对控制器的静态资源文件

当我们使用生成器生成脚手架或控制器时，Rails 会同时为控制器生成 JavaScript 文件（如果 Gemfile 中包含了 `coffee-rails` gem，那么生成的是 CoffeeScript 文件）和 CSS 文件（如果 Gemfile 中包含了 `sass-rails` gem，那么生成的是 SCSS 文件）。此外，在生成脚手架时，Rails 还会生成 `scaffolds.css` 文件（如果 Gemfile 中包含了 `sass-rails` gem，那么生成的是 `scaffolds.scss` 文件）。

例如，当我们生成 `ProjectsController` 时，Rails 会新建 `app/assets/javascripts/projects.coffee` 文件和 `app/assets/stylesheets/projects.scss` 文件。默认情况下，应用会通过 `require_tree` 指令引入这两个文件。关于 `require_tree` 指令的更多介绍，请参阅<<asset_pipeline#manifest-files-and-directives,清单文件和指令>>一节。

针对控制器的 JavaScript 文件和 CSS 文件也可以只在相应的控制器中引入：

`<%= javascript_include_tag params[:controller] %>` 或 `<%= stylesheet_link_tag params[:controller] %>`

此时，千万不要使用 `require_tree` 指令，否则就会重复包含这些静态资源文件。

WARNING: 在进行静态资源文件预编译时，请确保针对控制器的静态文件是在按页加载时进行预编译的。默认情况下，Rails 不会自动对 `.coffee` 和 `.scss` 文件进行预编译。关于预编译工作原理的更多介绍，请参阅<<asset_pipeline#precompiling-assets,预编译静态资源文件>>一节。

NOTE: 要想使用 CoffeeScript，就必须安装支持 ExecJS 的运行时。Mac OS X 和 Windows 已经预装了这样的运行时。关于所有可用运行时的更多介绍，请参阅 link:$$https://github.com/rails/execjs#readme$$[ExecJS] 文档。

通过在 `config/application.rb` 配置文件中添加下述代码，可以禁止生成针对控制器的静态资源文件：

[source,ruby]
----
config.generators do |g|
  g.assets false
end
----

[[asset-organization]]
==== 静态资源文件的组织方式

在应用中，有三个位置可以储存 Asset Pipeline 静态资源文件：`app/assets`、`lib/assets` 和 `vendor/assets`。

* `app/assets` 文件夹用于储存应用自有的静态资源文件，例如自定义图片、JavaScript 文件和 CSS 文件。

* `lib/assets` 文件夹用于储存自有代码库的静态资源文件，这些代码库或者不适合放在当前应用中，或者需要在多个应用间共享。

* `vendor/assets` 文件夹用于储存第三方代码库的静态资源文件，例如 JavaScript 插件和 CSS 框架。如果第三方代码库中引用了同样由 Asset Pipeline 处理的静态资源文件（图片、CSS 文件等），就必须使用 `asset_path` 这样的辅助方法重新编写相关代码。

WARNING: 从 Rails 3 升级而来的用户需要注意，通过设置应用的清单文件， 我们可以包含 `lib/assets` 和 `vendor/assets` 文件夹中的静态资源文件，但是这两个文件夹不再是预编译数组的一部分。更多介绍请参阅<<asset_pipeline#precompiling-assets,预编译静态资源文件>>一节。

[[search-paths]]
===== 搜索路径

当清单文件或辅助方法引用了静态资源文件时，Sprockets 会在静态资源文件的三个默认存储位置中进行查找。

这三个默认存储位置分别是 `app/assets` 文件夹的 `images`、`javascripts` 和 `stylesheets` 子文件夹，实际上这三个文件夹并没有什么特别之处，所有的 `app/assets/*` 文件夹及其子文件夹都会被搜索。

例如，下列文件：

----
app/assets/javascripts/home.js
lib/assets/javascripts/moovinator.js
vendor/assets/javascripts/slider.js
vendor/assets/somepackage/phonebox.js
----

在清单文件中可以像下面这样进行引用：

[source,javascript]
----
//= require home
//= require moovinator
//= require slider
//= require phonebox
----

这些文件夹的子文件夹中的静态资源文件：

----
app/assets/javascripts/sub/something.js
----

可以像下面这样进行引用：

[source,javascript]
----
//= require sub/something
----

通过在 Rails 控制台中检查 `Rails.application.config.assets.paths` 变量，我们可以查看搜索路径。

除了标准的 `app/assets/*` 路径，还可以在 `config/application.rb` 配置文件中为 Asset Pipeline 添加其他路径。例如：

[source,ruby]
----
config.assets.paths << Rails.root.join("lib", "videoplayer", "flash")
----

Rails 会按照路径在搜索路径中出现的先后顺序，对路径进行遍历。因此，在默认情况下，`app/assets` 中的文件优先级最高，将会遮盖 `lib` 和 `vendor` 文件夹中的同名文件。

千万注意，在清单文件之外引用的静态资源文件必须添加到预编译数组中，否则无法在生产环境中使用。

[[using-index-files]]
===== 使用索引文件

对于 Sprockets，名为 `index`（带有相关扩展名）的文件具有特殊用途。

例如，假设应用中使用的 jQuery 库及多个模块储存在 `lib/assets/javascripts/library_name` 文件夹中，那么 `lib/assets/javascripts/library_name/index.js` 文件将作为这个库的清单文件。在这个库的清单文件中，应该按顺序列出所有需要加载的文件，或者干脆使用 `require_tree` 指令。

在应用的清单文件中，可以把这个库作为一个整体加载：

[source,javascript]
----
//= require library_name
----

这样，相关代码总是作为整体在应用中使用，降低了维护成本，并使代码保持简洁。

[[coding-links-to-assets]]
==== 创建指向静态资源文件的链接

Sprockets 没有为访问静态资源文件添加任何新方法，而是继续使用我们熟悉的 `javascript_include_tag` 和 `stylesheet_link_tag` 辅助方法：

[source,erb]
----
<%= stylesheet_link_tag "application", media: "all" %>
<%= javascript_include_tag "application" %>
----

如果使用了 Rails 默认包含的 `turbolinks` gem，并使用了 `data-turbolinks-track` 选项，Turbolinks 就会检查静态资源文件是否有更新，如果有更新就加载到页面中：

[source,erb]
----
<%= stylesheet_link_tag "application", media: "all", "data-turbolinks-track" => "reload" %>
<%= javascript_include_tag "application", "data-turbolinks-track" => "reload" %>
----

在常规视图中，我们可以像下面这样访问 `public/assets/images` 文件夹中的图片：

[source,erb]
----
<%= image_tag "rails.png" %>
----

如果在应用中启用了 Asset Pipeline，并且未在当前环境中禁用 Asset Pipeline，那么这个图片文件将由 Sprockets 处理。如果图片的位置是 `public/assets/rails.png`，那么将由 Web 服务器处理。

如果文件请求包含哈希，例如 `public/assets/rails-af27b6a414e6da00003503148be9b409.png`，处理的方式也是一样的。关于如何生成哈希的介绍，请参阅<<asset_pipeline#in-production,在生产环境中>>一节。

Sprockets 还会检查 `config.assets.paths` 中指定的路径，其中包括 Rails 应用的标准路径和 Rails 引擎添加的路径。

也可以把图片放在子文件夹中，访问时只需加上子文件夹的名称即可：

[source,erb]
----
<%= image_tag "icons/rails.png" %>
----

WARNING: 如果对静态资源文件进行了预编译（请参阅<<asset_pipeline#in-production,在生产环境中>>一节），那么在页面中链接到并不存在的静态资源文件或空字符串将导致该页面抛出异常。因此，在使用 `image_tag` 等辅助方法处理用户提供的数据时一定要小心。

[[css-and-erb]]
===== CSS 和 ERB

Asset Pipeline 会自动计算 ERB 的值。也就是说，只要给 CSS 文件添加 `.erb` 扩展名（例如 `application.css.erb`），就可以在 CSS 规则中使用 `asset_path` 等辅助方法。

[source,erb]
----
.class { background-image: url(<%= asset_path 'image.png' %>) }
----

上述代码中的 `asset_path` 辅助方法会返回指向图片真实路径的链接。图片必须位于静态文件加载路径中，例如 `app/assets/images/image.png`，以便在这里引用。如果在 `public/assets` 文件夹中已经存在此图片的带指纹的版本，那么将引用这个带指纹的版本。

要想使用 link:$$http://en.wikipedia.org/wiki/Data_URI_scheme$$[data URI]（用于把图片数据直接嵌入 CSS 文件中），可以使用 `asset_data_uri` 辅助方法：

[source,erb]
----
#logo { background: url(<%= asset_data_uri 'logo.png' %>) }
----

`asset_data_uri` 辅助方法会把正确格式化后的 data URI 插入 CSS 源代码中。

注意，关闭标签不能使用 `-%>` 形式。

[[css-and-sass]]
===== CSS 和 Sass

在使用 Asset Pipeline 时，静态资源文件的路径都必须重写，为此 `sass-rails` gem 提供了 `-url` 和 `-path` 系列辅助方法（在 Sass 中使用连字符，在 Ruby 中使用下划线），用于处理图片、字体、视频、音频、JavaScript 和 CSS 等类型的静态资源文件。

* `image-url("rails.png")` 会返回 `url(/assets/rails.png)`
* `image-path("rails.png")` 会返回 `"/assets/rails.png"`

或使用更通用的形式：

* `asset-url("rails.png")` 返回 `url(/assets/rails.png)`
* `asset-path("rails.png")` 返回 `"/assets/rails.png"`

[[javascript-coffeescript-and-erb]]
===== JavaScript/CoffeeScript 和 ERB

只要给 JavaScript 文件添加 `.erb` 扩展名（例如 `application.js.erb`），就可以在 JavaScript 源代码中使用 `asset_path` 辅助方法：

[source,erb]
----
$('#logo').attr({ src: "<%= asset_path('logo.png') %>" });
----

上述代码中的 `asset_path` 辅助方法会返回指向图片真实路径的链接。

同样，只要给 CoffeeScript 文件添加 `.erb` 扩展名（例如 `application.coffee.erb`），就可以在 CoffeeScript 源代码中使用 `asset_path` 辅助方法：

[source,erb]
----
$('#logo').attr src: "<%= asset_path('logo.png') %>"
----

[[manifest-files-and-directives]]
==== 清单文件和指令

Sprockets 使用清单文件来确定需要包含和处理哪些静态资源文件。这些清单文件中的指令会告诉 Sprockets，要想创建 CSS 或 JavaScript 文件需要加载哪些文件。通过这些指令，可以让 Sprockets 加载指定文件，对这些文件进行必要的处理，然后把它们连接为单个文件，最后进行压缩（压缩方式取决于 `Rails.application.config.assets.js_compressor` 选项的值）。这样在页面中只需处理一个文件而非多个文件，减少了浏览器的请求次数，大大缩短了页面的加载时间。通过压缩还能使文件变小，使浏览器可以更快地下载。

例如，在默认情况下，新建 Rails 应用的 `app/assets/javascripts/application.js` 文件包含下面几行代码：

[source,javascript]
----
// ...
//= require jquery
//= require jquery_ujs
//= require_tree .
----

在 JavaScript 文件中，Sprockets 指令以 `//=.` 开头。上述代码中使用了 `require` 和 `require_tree` 指令。`require` 指令用于告知 Sprockets 哪些文件需要加载。这里加载的是 Sprockets 搜索路径中的 `jquery.js` 和 `jquery_ujs.js` 文件。我们不必显式提供文件的扩展名，因为 Sprockets 假定在 `.js` 文件中加载的总是 `.js` 文件。

`require_tree` 指令告知 `Sprockets` 以递归方式包含指定文件夹中的所有 JavaScript 文件。在指定文件夹路径时，必须使用相对于清单文件的相对路径。也可以通过 `require_directory` 指令包含指定文件夹中的所有 JavaScript 文件，此时将不会采取递归方式。

清单文件中的指令是按照从上到下的顺序处理的，但我们无法确定 `require_tree` 指令包含文件的顺序，因此不应该依赖于这些文件的顺序。如果想要确保连接文件时某些 JavaScript 文件出现在其他 JavaScript 文件之前，可以在清单文件中先行加载这些文件。注意，`require` 系列指令不会重复加载文件。

在默认情况下，新建 Rails 应用的 `app/assets/stylesheets/application.css` 文件包含下面几行代码：

[source,css]
----
/* ...
*= require_self
*= require_tree .
*/
----

无论新建 Rails 应用时是否使用了 `--skip-sprockets` 选项，Rails 都会创建 `app/assets/javascripts/application.js` 和 `app/assets/stylesheets/application.css` 文件。因此，之后想要使用 Asset Pipeline 非常容易。

我们在 JavaScript 文件中使用的指令同样可以在 CSS 文件中使用，此时加载的是 CSS 文件而不是 JavaScript 文件。在 CSS 清单文件中，`require_tree` 指令的工作原理和在 JavaScript 清单文件中相同，会加载指定文件夹中的所有 CSS 文件。

上述代码中使用了 `require_self` 指令，用于把当前文件中的 CSS 代码（如果存在）插入调用这个指令的位置。

NOTE: 要想使用多个 Sass 文件，通常应该使用 link:$$http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import$$[Sass @import 规则]，而不是 Sprockets 指令。如果使用 Sprockets 指令，这些 Sass 文件将拥有各自的作用域，这样变量和混入只能在定义它们的文件中使用。

和使用 `require_tree` 指令相比，使用 `@import "*"` 和 `@import "**/*"` 的效果完全相同，都能加载指定文件夹中的所有文件。更多介绍和注意事项请参阅 link:$$https://github.com/rails/sass-rails#features$$[sass-rails 文档]。

我们可以根据需要使用多个清单文件。例如，可以用 `admin.js` 和 `admin.css` 清单文件分别包含应用管理后台的 JS 和 CSS 文件。

CSS 清单文件中指令的执行顺序类似于前文介绍的 JavaScript 清单文件，尤其是加载的文件都会按照指定顺序依次编译。例如，我们可以像下面这样把 3 个 CSS 文件连接在一起：

[source,css]
----
/* ...
*= require reset
*= require layout
*= require chrome
*/
----

[[preprocessing]]
==== 预处理

静态资源文件的扩展名决定了预处理的方式。在使用默认的 Rails gemset 生成控制器或脚手架时，会生成 CoffeeScript 和 SCSS 文件，而不是普通的 JavaScript 和 CSS 文件。在前文的例子中，生成 `projects` 控制器时会生成 `app/assets/javascripts/projects.coffee` 和 `app/assets/stylesheets/projects.scss` 文件。

在开发环境中，或 Asset Pipeline 被禁用时，会使用 `coffee-script` 和 `sass` gem 提供的处理器分别处理相应的文件请求，并把生成的 JavaScript 和 CSS 文件发给浏览器。当 Asset Pipeline 可用时，会对这些文件进行预处理，然后储存在 `public/assets` 文件夹中，并由 Rails 应用或 Web 服务器处理。

通过添加其他扩展名，可以对文件进行更多预处理。对扩展名的解析顺序是从右到左，相应的预处理顺序也是从右到左。例如，对于 `app/assets/stylesheets/projects.scss.erb` 文件，会先处理 ERB，再处理 SCSS，最后作为 CSS 文件处理。同样，对于 `app/assets/javascripts/projects.coffee.erb` 文件，会先处理 ERB，再处理 CoffeeScript，最后作为 JavaScript 文件处理。

记住预处理顺序很重要。例如，如果我们把文件名写为 `app/assets/javascripts/projects.erb.coffee`，就会先处理 CoffeeScript，这时一旦遇到 ERB 代码就会出错。

[[in-development]]
=== 在开发环境中
