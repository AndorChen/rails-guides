[[ruby-on-rails-security-guide]]
== Ruby on Rails 安全指南
:imagesdir: ../images
:numbered:

// chinakr 翻译

[.chapter-abstract]
--
本文介绍 Web 应用中常见的安全问题，以及如何在 Rails 中避免这些问题。

读完本文后，您将学到：

* 所有需要强调的安全对策；
* Rails 中会话的概念，应该在会话中保存什么内容，以及常见的攻击方式；
* 为什么访问网站也可能带来安全问题（跨站请求伪造）；
* 处理文件或提供管理界面时需要注意的问题；
* 如何管理用户：登录、退出，以及不同层次上的攻击方式；
* 最常见的注入攻击方式。
--

[[introduction]]
=== 简介

Web 应用框架的作用是帮助开发者创建 Web 应用。其中一些框架还能帮助我们提高 Web 应用的安全性。事实上，框架之间无所谓谁更安全，对于许多框架来说，只要使用正确，我们都能开发出安全的应用。Ruby on Rails 提供了一些十分智能的辅助方法，例如，用于防止 SQL 注入的辅助方法，极大减少了这一安全风险。

一般来说，并不存在什么即插即用的安全机制。安全性取决于开发者如何使用框架，有时也取决于开发方式。安全性还取决于 Web 应用环境的各个层面，包括后端存储、Web 服务器和 Web 应用自身等（甚至包括其他 Web应用）。

不过，据高德纳咨询公司（Gartner Group）估计，75% 的攻击发生在 Web 应用层面，报告称“在进行了安全审计的 300 个网站中，97% 存在被攻击的风险”。这是因为针对 Web 应用的攻击相对来说更容易实施，其工作原理和具体操作都比较简单，即使是非专业人士也能发起攻击。

针对 Web 应用的安全威胁包括账户劫持、绕过访问控制、读取或修改敏感数据，以及显示欺诈信息等。有时，攻击者还会安装木马程序或使用垃圾邮件群发软件，以便获取经济利益，或者通过篡改公司资源来损害品牌形象。为了防止这些攻击，最大限度降低或消除攻击造成的影响，首先我们必须全面了解各种攻击方式，只有这样才能找出正确对策——这正是本文的主要目的。

为了开发安全的 Web 应用，我们必须从各个层面紧跟安全形势，做到知己知彼。为此，我们可以订阅安全相关的邮件列表，阅读相关博客，同时养成及时更新并定期进行安全检查的习惯（请参阅<<security#additional-resources,其他资源>>一节）。这些工作都是手动完成的，只有这样我们才能发现潜在安全隐患。

[[sessions]]
=== 会话

从会话入手来了解安全问题是一个很好的切入点，因为会话对于特定攻击十分脆弱。

[[what-are-sessions]]
==== 会话是什么

NOTE: HTTP 是无状态协议，会话使其有状态。

大多数应用需要跟踪特定用户的某些状态，例如购物车里的商品、当前登录用户的 ID 等。如果没有会话，就需要为每一次请求标识用户甚至进行身份验证。当新用户访问应用时，Rails 会自动新建会话，如果用户曾经访问过应用，就会加载已有会话。

会话通常由值的散列和会话 ID（通常为 32 个字符的字符串）组成，其中会话 ID 用于标识散列。发送到客户端浏览器的每个 Cookie 都包含会话 ID，另一方面，客户端浏览器发送到服务器的每个请求也包含会话 ID。在 Rails 中，我们可以使用 `session` 方法保存和取回值：

[source,ruby]
----
session[:user_id] = @current_user.id
User.find(session[:user_id])
----

[[session-id]]
==== 会话 ID

NOTE: 会话 ID 是长度为 32 字节的 MD5 散列值。

会话 ID 由随机字符串的散列值组成。这个随机字符串包含当前时间，一个 0 到 1 之间的随机数，Ruby 解析器的进程 ID（基本上也是一个随机数），以及一个常量字符串。目前 Rails 会话 ID 还无法暴力破解。尽管直接破解 MD5 很难，但存在 MD5 碰撞的可能性，理论上可以创建具有相同散列值的另一个输入文本。不过到目前为止，这个问题还未产生安全影响。

[[session-hijacking]]
==== 会话劫持

WARNING: 通过窃取用户的会话 ID，攻击者能够以受害者的身份使用 Web 应用。

很多 Web 应用都有身份验证系统：用户提供用户名和密码，Web 应用在验证后把对应的用户 ID 储存到会话散列中。之后，会话就可以合法使用了。对于每个请求，应用都会通过识别会话中储存的用户 ID 来加载用户，从而避免了重新进行身份验证。Cookie 中的会话 ID 用于标识会话。

因此，Cookie 提供了 Web 应用的临时身份验证。只要得到了他人的 Cookie，任何人都能以该用户的身份使用 Web 应用，这可能导致严重的后果。下面介绍几种劫持会话的方式及其对策：

* 在不安全的网络中嗅探 Cookie。无线局域网就是一个例子。在未加密的无线局域网中，监听所有已连接客户端的流量极其容易。因此，Web 应用开发者应该通过 SSL 提供安全连接。在 Rails 3.1 和更高版本中，可以在应用配置文件中设置强制使用 SSL 连接：

[source,ruby]
----
config.force_ssl = true
----

* 大多数人在使用公共终端后不会清除 Cookie。因此，如果最后一个用户没有退出 Web 应用，后续用户就能以该用户的身份继续使用。因此，Web 应用一定要提供“退出”按钮，并且要尽可能显眼。

* 很多跨站脚本（XSS）攻击的目标是获取用户 Cookie。更多介绍请参阅<<security#cross-site-scripting-xss,跨站脚本攻击>>一节。

* 有的攻击者不窃取 Cookie，而是篡改用户 Cookie 中的会话 ID。这种攻击方式被称为固定会话攻击，后文会详细介绍。

大多数攻击者的主要目标是赚钱。根据赛门铁克《互联网安全威胁报告》，被窃取的银行登录账户的黑市价格从 10 到 1000 美元不等（取决于账户余额），信用卡卡号为 0.40 到 20 美元，在线拍卖网站的账户为 1 到 8 美元，电子邮件账户密码为 4 到 30 美元。

[[session-guidelines]]
==== 会话安全指南

下面是一些关于会话安全的一般性指南。

* 不要在会话中储存大型对象，而应该把它们储存在数据库中，并将其 ID 保存在会话中。这么做可以避免同步问题，并且不会导致会话存储空间耗尽（会话存储空间的大小取决于其类型，详见后文）。如果不这么做，当修改了对象结构时，用户 Cookie 中保存的仍然是对象的旧版本。通过在服务器端储存会话，我们可以轻而易举地清除会话，而在客户端储存会话，要想清除会话就很麻烦了。

* 关键数据不应该储存在会话中。如果用户清除了 Cookie 或关闭了浏览器，这些关键数据就会丢失。并且在客户端储存会话，还会导致用户能够读取关键数据。

[[session-storage]]
==== 会话存储

NOTE: Rails 提供了几种会话散列的存储机制。其中最重要的是 `ActionDispatch::Session::CookieStore`。

Rails 2 引入了一种新的默认会话存储机制——CookieStore。CookieStore 把会话散列直接储存在客户端的 Cookie 中。无需会话 ID，服务器就可以从 Cookie 中取回会话散列。这么做可以显著提高程序的运行速度，但也存在争议，因为这种存储机制具有下列安全隐患：

* Cookie 的大小被严格限制为 4 KB。这个限制本身没问题，因为如前文所述，本来就不应该在会话中储存大量数据。在会话中储存当前用户的数据库 ID 一般没问题。

* 客户端可以看到储存在会话中的所有内容，因为数据是以明文形式储存的（实际上是 Base64 编码，因此没有加密）。因此，我们不应该在会话中储存隐私数据。为了防止会话散列被篡改，应该根据服务器端密令（`secrets.secret_token`）计算会话的摘要（digest），然后把这个摘要添加到 Cookie 的末尾。

不过，从 Rails 4 开始，默认存储机制是 EncryptedCookieStore。EncryptedCookieStore 会先对会话进行加密，再储存到 Cookie 中。这么做可以防止用户访问和篡改 Cookie 的内容。因此，会话也成为储存数据的更安全的地方。加密时需要使用 `config/secrets.yml` 文件中储存的服务器端密钥 `secrets.secret_key_base`。

这意味着 EncryptedCookieStore 存储机制的安全性由密钥（以及摘要算法，出于兼容性考虑默认为 SHA1 算法）决定。因此，密钥不能随意取值，例如从字典中找一个单词，或少于 30 个字符，应该使用 `rails secret` 生成密钥。

`secrets.secret_key_base` 用于指定密钥，在应用中会话使用这个密钥来验证已知密钥，以防止篡改。在创建应用时，`config/secrets.yml` 文件中储存的 `secrets.secret_key_base` 是一个随机密钥，例如：

[source,yml]
----
development:
  secret_key_base: a75d...

test:
  secret_key_base: 492f...

production:
  secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
----

Rails 老版本中的 CookieStore 使用的是 `secret_token`，而不是 EncryptedCookieStore 所使用的 `secret_key_base`。更多介绍请参阅升级文档。

如果应用的密钥泄露了（例如应用开放了源代码），强烈建议更换密钥。

[[replay-attacks-for-cookiestore-sessions]]
==== 对 CookieStore 会话的重放攻击（replay attack）

NOTE: 重放攻击是使用 CookieStore 时必须注意的另一种攻击方式。

重放攻击的工作原理如下：

* 用户获得的信用额度保存在会话中（信用额度实际上不应该保存在会话中，这里只是出于演示目的才这样做）；
* 用户使用部分信用额度购买商品；
* 减少后的信用额度仍然保存在会话中；
* 用户先前复制了第一步中的 Cookie，并用这个 Cookie 替换浏览器中的当前 Cookie；
* 用户重新获得了消费前的信用额度。

在会话中包含随机数可以防止重放攻击。每个随机数验证一次后就会失效，服务器必须跟踪所有有效的随机数。当有多个应用服务器时，情况会变得更复杂，因为我们不能把随机数储存在数据库中，否则就违背了使用 CookieStore 的初衷（避免访问数据库）。

因此，防止重放攻击的最佳方案，不是把这类敏感数据储存在会话中，而是把它们储存在数据库中。回到上面的例子，我们可以把信用额度储存在数据库中，而把当前用户的 ID 储存在会话中。

[[session-fixation]]
==== 会话固定攻击（session fixation）

NOTE: 除了窃取用户的会话 ID 之外，攻击者还可以直接使用已知的会话 ID。这种攻击方式被称为会话固定攻击。

image::session_fixation.png[]

会话固定攻击的关键是强制用户的浏览器使用攻击者已知的会话 ID，这样攻击者就无需窃取会话 ID。会话固定攻击的工作原理如下：

* 攻击者创建一个有效的会话 ID：打开 Web 应用的登录页面，从响应中获取 Cookie 中的会话 ID（参见上图中的第 1 和第 2 步）。
* 攻击者定期访问 Web 应用，以避免会话过期。
* 攻击者强制用户的浏览器使用这个会话 ID（参见上图中的第 3 步）。由于无法修改另一个域名的 Cookie（基于同源原则的限制），攻击者必须在目标 Web 应用的域名上运行 JavaScript，也就是通过 XSS 把 JavaScript 注入目标 Web 应用来完成攻击。例如：`<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>`。关于 XSS 和注入的更多介绍见后文。
* 攻击者诱使用户访问包含恶意 JavaScript 代码的页面，这样用户的浏览器中的会话 ID 就会被篡改为攻击者已知的会话 ID。
* 由于这个被篡改的会话还未使用过，Web 应用会进行身份验证。
* 此后，用户和攻击者将共用同一个会话来访问 Web 应用。攻击者篡改后的会话成为了有效会话，用户面对攻击却浑然不知。

[[session-fixation-countermeasures]]
==== 会话固定攻击的对策

TIP: 一行代码就能保护我们免受会话固定攻击。

面对会话固定攻击，最有效的对策是在登录成功后重新设置会话 ID，并使原有会话 ID 失效，这样攻击者持有的会话 ID 也就失效了。这也是防止会话劫持的有效对策。在 Rails 中重新设置会话 ID 的方式如下：

[source,ruby]
----
reset_session
----

如果我们使用流行的 link:$$https://rubygems.org/gems/devise[Devise] gem 完成用户管理，Devise 会在用户登录和退出时自动使原有会话过期。如果打算手动完成用户管理，请记住在登录操作后（新会话创建后）使原有会话过期。会话过期后其中的值都会被删除，因此我们需要把有用的值转移到新会话中。

另一个对策是在会话中保存用户相关的属性，对于每次请求都验证这些属性，如果信息不匹配就拒绝访问。这些属性包括 IP 地址、用户代理（Web 浏览器名称），其中用户代理的用户相关性要弱一些。在保存 IP 地址时，必须注意，有些网络服务提供商（ISP）或大型组织，会把用户置于代理服务器之后。在会话的生命周期中，这些代理服务器有可能发生变化，从而导致用户无法正常使用应用，或出现权限问题。

[[session-expiry]]
==== 会话过期

NOTE: 永不过期的会话增加了跨站请求伪造（CSRF）、会话劫持和会话固定攻击的风险。

Cookie 的过期时间可以通过会话 ID 设置。然而，客户端能够修改储存在 Web 浏览器中的 Cookie，因此在服务器上使会话过期更安全。下面的例子演示了如何使储存在数据库中的会话过期。通过调用 `Session.sweep("20 minutes")`，可以使闲置超过 20 分钟的会话过期。

[source,ruby]
----
class Session < ApplicationRecord
  def self.sweep(time = 1.hour)
    if time.is_a?(String)
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end

    delete_all "updated_at < '#{time.ago.to_s(:db)}'"
  end
end
----

“会话固定攻击”一节介绍了维护会话的问题。攻击者每五分钟维护一次会话，就可以使会话永远保持活动，不会过期。针对这个问题的一个简单解决方案是在会话数据表中添加 `created_at` 字段，这样就可以找出创建了很长时间的会话并删除它们。可以用下面这行代码代替上面例子中的对应代码：

[source,ruby]
----
delete_all "updated_at < '#{time.ago.to_s(:db)}' OR
  created_at < '#{2.days.ago.to_s(:db)}'"
----

[[cross-site-request-forgery-csrf]]
=== 跨站请求伪造（CSRF）

跨站请求伪造的工作原理是，通过在页面中包含恶意代码或链接，访问已验证用户才能访问的 Web 应用。如果该 Web 应用的会话未超时，攻击者就能执行未经授权的操作。

image::csrf.png[]

在<<security#sessions,会话>>一节中，我们了解到大多数 Rails 应用都使用基于 Cookie 的会话。它们或者把会话 ID 储存在 Cookie 中并在服务器端储存会话散列，或者把整个会话散列储存在客户端。不管是哪种情况，只要浏览器能够找到某个域名对应的 Cookie，就会自动在发送请求时包含该 Cookie。有争议的是，即便请求来源于另一个域名上的网站，浏览器在发送请求时也会包含客户端的 Cookie。让我们来看个例子：

* 鲍勃在访问留言板时浏览了一篇黑客发布的帖子，其中有一个精心设计的 HTML 图片元素。这个元素实际指向的是鲍勃的项目管理应用中的某个操作，而不是真正的图片文件：`<img src="http://www.webapp.com/project/1/destroy">`。
* 鲍勃在 pass:[www.webapp.com] 上的会话仍然是活动的，因为几分钟前他访问这个应用后没有退出。
* 当鲍勃浏览这篇帖子时，浏览器发现了这个图片标签，于是尝试从 pass:[www.webapp.com] 上加载图片。如前文所述，浏览器在发送请求时包含了 Cookie，其中包含了有效的会话 ID。
* pass:[www.webapp.com] 上的 Web 应用会验证对应会话散列中的用户信息，并删除 ID 为 1 的项目，然后返回结果页面。由于返回的并非浏览器所期待的结果，图片无法显示。
* 鲍勃当时并未发觉受到了攻击，但几天后，他发现 ID 为 1 的项目不见了。

有一点需要特别注意，像上面这样精心设计的图片或链接，并不一定要出现在 Web 应用所在的域名上，而是可以出现在任何地方，例如论坛、博客帖子，甚至电子邮件中。

CSRF 在 CVE（Common Vulnerabilities and Exposures，公共漏洞披露）中很少出现，在 2006 年不到 0.1%，但却是个可怕的隐形杀手。对于很多安全保障工作来说，CSRF 是一个严重的安全问题。

[[csrf-countermeasures]]
==== CSRF 对策

NOTE: 首先，根据 W3C 的要求，应该适当地使用 `GET` 和 `POST` HTTP 方法。其次，在非 GET 请求中使用安全令牌（security token），可以防止应用受到 CSRF 攻击。

HTTP 协议提供了两种主要的基本请求类型，`GET` 和 `POST`（还有其他请求类型，但大多数浏览器不支持）。万维网联盟（W3C）提供了检查表，以帮助开发者在 `GET` 和 `POST` 这两个 HTTP 方法之间做出正确选择：

使用 `GET` HTTP 方法的情形：

* 当交互更像是在询问时，例如查询、读取、查找等安全操作。

使用 `POST` HTTP 方法的情形：

* 当交互更像是在执行命令时；
* 当交互改变了资源的状态并且这种变化能够被用户察觉时，例如订阅某项服务；
* 当用户需要对交互结果负责时。

如果应用是 REST 式的，我们还可以使用附加的 HTTP 方法，例如 `PATCH`、`PUT` 或 `DELETE`。然而现今的大多数浏览器都不支持这些 HTTP 方法，只有 `GET` 和 `POST` 得到了普遍支持。Rails 通过隐藏的 `_method` 字段来解决这个问题。

`POST` 请求也可以自动发送。在下面的例子中，链接 pass:[www.harmless.com] 在浏览器状态栏中显示为目标地址，实际上却动态新建了一个发送 POST 请求的表单：

[source,ruby]
----
<a href="http://www.harmless.com/" onclick="
  var f = document.createElement('form');
  f.style.display = 'none';
  this.parentNode.appendChild(f);
  f.method = 'POST';
  f.action = 'http://www.example.com/account/destroy';
  f.submit();
  return false;">To the harmless survey</a>
----

攻击者还可以把代码放在图片的 `onmouseover` 事件句柄中：

[source,html]
----
<img src="http://www.harmless.com/img" width="400" height="400" onmouseover="..." />
----

CSRF 还有很多可能的攻击方式，例如使用 `<script>` 标签向返回 JSONP 或 JavaScript 的 URL 地址发起跨站请求。对跨站请求的响应，返回的如果是攻击者可以设法运行的可执行代码，就有可能导致敏感数据泄露。为了避免发生这种情况，我们必须禁用跨站 `<script>` 标签。不过 Ajax 请求是遵循同源原则的（只有在同一个网站中才能初始化 `XmlHttpRequest`），因此在响应 Ajax 请求时返回 JavaScript 是安全的，不必担心跨站请求问题。

注意：我们无法区分 `<script>` 标签的来源，无法知道这个标签是自己网站上的，还是其他恶意网站上的，因此我们必须全面禁止 `<script>` 标签，哪怕这个标签实际上来源于自己网站上的安全的同源脚本。在这种情况下，对于返回 JavaScript 的控制器动作，显式跳过 CSRF 保护，就意味着允许使用 `<scipt>` 标签。

为了防止其他各种伪造请求，我们引入了安全令牌，这个安全令牌只有我们自己的网站知道，其他网站不知道。我们把安全令牌包含在请求中，并在服务器上进行验证。这是应用的控制器中的一个线程，也是新建 Rails 应用的默认值：

[source,ruby]
----
protect_from_forgery with: :exception
----

这行代码会在 Rails 生成的所有表单和 Ajax 请求中包含安全令牌。如果安全令牌验证失败，就会抛出异常。

NOTE: 默认情况下，Rails 会包含 jQuery 和 jQuery 非侵入式适配器，后者会在 jQuery 的每个非 GET Ajax 调用中添加名为 `X-CSRF-Token` 的头信息，其中包含安全令牌。如果没有这个头信息，Rails 不会接受非 GET Ajax 请求。当使用其他库进行 Ajax 调用时，同样需要把安全令牌作为 Ajax 调用的默认头信息添加到库中。要想获取令牌，请查看应用视图中由 `<%= csrf_meta_tags %>` 这行代码生成的 `<meta name='csrf-token' content='THE-TOKEN'>` 标签。

通常我们会使用持久化 Cookie 来储存用户信息，例如使用 `cookies.permanent`。在这种情况下，Cookie 不会被清除，CSRF 保护也无法自动生效。如果使用了其他 Cookie 存储而不是会话来保存用户信息，我们就必须手动解决这个问题：

[source,ruby]
----
rescue_from ActionController::InvalidAuthenticityToken do |exception|
  sign_out_user # 删除用户 Cookie 的示例方法
end
----

这段代码可以放在 `ApplicationController` 中。对于非 GET 请求，如果 CSRF 令牌不存在或不正确，就会执行这段代码。

注意，跨站脚本（XSS）漏洞能够绕过所有 CSRF 保护。攻击者通过 XSS 可以访问页面中的所有元素，也就是说攻击者可以读取表单中的 CSRF 安全令牌，也可以直接提交表单。更多介绍请参阅<<security#cross-site-scripting-xss,跨站脚本>>一节。

[[redirection-and-files]]
=== 重定向和文件
