[[active-record-query-interface]]
== Active Record 查询
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
本文介绍使用 Active Record 从数据库取回数据的不同方法。

读完后，你将学会：

* 如何使用多种方法和条件查找记录。
* 如何指定所查找记录的排序方式、想要取回的属性、分组方式和其他特性。
* 如何使用预先加载以减少数据检索所需的数据库查询的数量。
* 如何使用动态查找器方法。
* 如何通过方法链来连续使用多个 Active Record 方法。
* 如何检查某个记录是否存在。
* 如何在 Active Record 模型上做各种计算。
* 如何在关联上执行 `EXPLAIN` 命令。
--

如果你习惯直接使用 SQL 来查找数据库记录，那么你通常会发现 Rails 为执行相同操作提供了更好的方式。在大多数情况下，Active Record 使你无需使用 SQL。

本文中的示例代码会用到下面的一个或多个模型：

NOTE: 除非另有说明，下面所有模型都使用 `id` 作为主键。

[source,ruby]
----
class Client < ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
----

[source,ruby]
----
class Address < ApplicationRecord
  belongs_to :client
end
----

[source,ruby]
----
class Order < ApplicationRecord
  belongs_to :client, counter_cache: true
end
----

[source,ruby]
----
class Role < ApplicationRecord
  has_and_belongs_to_many :clients
end
----

Active Record 会为你执行数据库查询，它和大多数数据库系统兼容，包括 MySQL、MariaDB、PostgreSQL 和 SQLite。不管使用哪个数据库系统，Active Record 方法的用法总是相同。

[[retrieving-objects-from-the-database]]
=== 从数据库取回对象

Active Record 提供了几个用于从数据库取回对象的查找器方法。查找器方法接受参数并执行指定的数据库查询，使我们无需直接使用 SQL。

下面列出了这些查找器方法：

* `find`
* `create_with`
* `distinct`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `left_outer_joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `distinct`
* `where`

上面的所有方法都会返回 `ActiveRecord::Relation` 的实例。

`Model.find(options)` 执行的主要操作可以概括为：

* 把提供的选项转换为等价的 SQL 查询。
* 触发 SQL 查询并从数据库取回对应结果。
* 为每个查询结果实例化对应的模型对象。
* 当存在回调时，先调用 `after_find` 回调再调用 `after_initialize` 回调。

[[retrieving-a-single-object]]
==== 取回单个对象

Active Record 为取回单个对象提供了几个不同的方法。

[[find]]
===== `find` 方法

可以使用 `find` 方法取回指定主键对应的对象，指定主键时可以使用多个选项。例如：

[source,ruby]
----
# Find the client with primary key (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
----

如果没有找到匹配的记录，`find` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

还可以使用 `find` 方法查询多个对象，方法是调用 `find` 方法并传入主键的数组。返回值是包含所提供的主键的所有匹配记录的数组。例如：

[source,ruby]
----
# Find the clients with primary keys 1 and 10.
client = Client.find([1, 10]) # Or even Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients WHERE (clients.id IN (1,10))
----

WARNING: 如果所提供的主键都没有匹配记录，那么 `find` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

[[take]]
===== `take` 方法

`take` 方法会取回一条记录而不考虑排序问题。例如：

[source,ruby]
----
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients LIMIT 1
----

如果没有找到记录，`take` 方法会返回 `nil`，而不会引发异常。

`take` 方法接受数字作为参数，并返回不超过指定数量的查询结果。例如：

[source,ruby]
----
client = Client.take(2)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 220, first_name: "Sara">
# ]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients LIMIT 2
----

`take!` 方法的行为和 `take` 方法类似，区别在于如果没有找到匹配的记录，`take!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

NOTE: 对于不同的数据库引擎，`take` 方法取回的记录可能不一样。

[[first]]
===== `first` 方法

`first` 方法默认会查找按主键排序的第一条记录。例如：

[source,ruby]
----
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
----

如果没有找到匹配的记录，`first` 方法会返回 `nil`，而不会引发异常。

如果默认作用域 （请参阅 <<hactive_record_querying#applying-a-default-scope>> 一节）包含排序方法，`first` 方法会返回按照这个顺序排序的第一条记录。

`first` 方法接受数字作为参数，并返回不超过指定数量的查询结果。例如：

[source,ruby]
----
client = Client.first(3)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 2, first_name: "Fifo">,
#   #<Client id: 3, first_name: "Filo">
# ]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
----

对于使用 `order` 排序的集合，`first` 方法返回按照指定属性排序的第一条记录。例如：

[source,ruby]
----
client = Client.order(:first_name).first
# => #<Client id: 2, first_name: "Fifo">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
----

`first!` 方法的行为和 `first` 方法类似，区别在于如果没有找到匹配的记录，`first!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

[[last]]
===== `last` 方法

`last` 方法默认会查找按主键排序的最后一条记录。例如：

[source,ruby]
----
client = Client.last
# => #<Client id: 221, first_name: "Russel">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
----

如果没有找到匹配的记录，`last` 方法会返回 `nil`，而不会引发异常。

如果默认作用域 （请参阅 <<hactive_record_querying#applying-a-default-scope>> 一节）包含排序方法，`last` 方法会返回按照这个顺序排序的最后一条记录。

`last` 方法接受数字作为参数，并返回不超过指定数量的查询结果。例如：

[source,ruby]
----
client = Client.last(3)
# => [
#   #<Client id: 219, first_name: "James">,
#   #<Client id: 220, first_name: "Sara">,
#   #<Client id: 221, first_name: "Russel">
# ]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
----

对于使用 `order` 排序的集合，`last` 方法返回按照指定属性排序的最后一条记录。例如：

[source,ruby]
----
client = Client.order(:first_name).last
# => #<Client id: 220, first_name: "Sara">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
----

`last!` 方法的行为和 `last` 方法类似，区别在于如果没有找到匹配的记录，`last!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

[[find-by]]
===== `find_by` 方法

`find_by` 方法查找匹配指定条件的第一条记录。 例如：

[source,ruby]
----
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by first_name: 'Jon'
# => nil
----

上面的代码等价于：

[source,ruby]
----
Client.where(first_name: 'Lifo').take
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
----

`find_by!` 方法的行为和 `find_by` 方法类似，区别在于如果没有找到匹配的记录，`find_by!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。例如：

[source,ruby]
----
Client.find_by! first_name: 'does not exist'
# => ActiveRecord::RecordNotFound
----

上面的代码等价于：

[source,ruby]
----
Client.where(first_name: 'does not exist').take!
----

[[retrieving-multiple-objects-in-batches]]
==== 批量取回多个对象

我们常常需要遍历大量记录，例如向大量用户发送时事通讯、导出数据等。

处理这类问题的方法看起来可能很简单：

[source,ruby]
----
# This is very inefficient when the users table has thousands of rows.
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end
----

但随着数据表越来越大，这种方法越来越行不通，因为 `User.all.each` 会使 Active Record 一次性取回整个数据表，为每条记录创建模型对象，并把整个模型对象数组保存在内存中。事实上，如果我们有大量记录，整个模型对象数组需要占用的空间可能会超过可用的内存容量。

Rails 提供了两种方法来解决这个问题，两种方法都是把整个记录分成多个对内存友好的批处理。第一种方法是通过 `find_each` 方法每次取回一批记录，然后逐一把每条记录作为模型传入块。第二种方法是通过 `find_in_batches` 方法每次取回一批记录，然后把这批记录批整个作为模型数组传入块。

NOTE: `find_each` 和 `find_in_batches` 方法用于大量记录的批处理，这些记录数量很大以至于不适合一次性保存在内存中。如果只需要循环 1000 条记录，那么应该首选常规的 `find` 方法。

[[find-each]]
===== `find_each` 方法

`find_each` 方法取回一批记录，然后逐一把每条记录作为模型传入块。在下面的例子中，`find_each` 方法取回 1000 条记录（`find_each` 和 `find_in_batches` 方法默认一次取回 1000 条记录），然后逐一把每条记录作为模型传入块。这一过程会不断重复，直到完成所有记录的处理：

[source,ruby]
----
User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
----

要想为 `find_each` 操作添加条件，我们可以链接其他 Active Record 方法，例如 `where` 方法：

[source,ruby]
----
User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
----

[[options-for-find-each]]
====== `find_each` 方法的选项

`find_each` 方法可以使用 `find` 方法的大多数选项，但 `:order` 和 `:limit` 选项例外，它们是 `find_each` 方法内部使用的保留选项。

`find_each` 方法还可以使用 `:batch_size`、`:start` 和 `:finish` 这三个附加选项。

**`:batch_size`**

`:batch_size` 选项用于说明批量取回记录时一次取回多少条记录。例如，一次取回 5000 条记录：

[source,ruby]
----
User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
----

**`:start`**

记录默认是按主键的升序方式取回的，这里的主键必须是整数。`:start` 选项用于配置想要取回的记录序列的第一个 ID，比这个 ID 小的记录都不会取回。这个选项有时候很有用，例如当需要恢复之前中断的批处理时，只需从最后一个取回的记录之后开始继续处理即可。

下面的例子把时事通讯发送给主键从 2000 开始的用户，一次取回 5000 条用户记录：

[source,ruby]
----
User.find_each(start: 2000, batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
----

`:finish`

和 `:start` 选项类似，`:finish` 选项用于配置想要取回的记录序列的最后一个 ID，比这个 ID 大的记录都不会取回。这个选项有时候很有用，例如可以通过配置 `:start` 和 `:finish` 选项来说明想要批处理的子记录集。

下面的例子把时事通讯发送给主键从 2000 到 10000 的用户，一次取回 5000 条用户记录：

[source,ruby]
----
User.find_each(start: 2000, finish: 10000, batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
----

另一个例子是使用多个 worker 处理同一个进程队列。通过分别配置 `:start` 和 `:finish` 选项可以让每个 worker 每次都处理 10000 条记录。

[[find-in-batches]]
===== `find_in_batches` 方法

`find_in_batches` 方法和 `find_each` 方法类似，两者都是批量取回记录。区别在于，`find_in_batches` 方法会把一批记录作为模型数组传入块，而不是像 `find_each` 方法那样逐一把每条记录作为模型传入块。下面的例子每次把 1000 张发票的数组一次性传入块（最后一次传入块的数组中的发票数量可能不到 1000）：

[source,ruby]
----
# Give add_invoices an array of 1000 invoices at a time
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end
----

[[options-for-find-in-batches]]
====== `find_in_batches` 方法的选项

和 `find_each` 方法一样，`find_in_batches` 方法可以使用 `:batch_size`、`:start` 和 `:finish` 选项。

[[conditions]]
=== 条件查询

`where` 方法用于说明限制返回记录所使用的条件，相当于 SQL 语句的 `WHERE` 部分。这里的条件可以是字符串、数组或 Hash。

[[pure-string-conditions]]
==== 纯字符串条件

可以直接用纯字符串来为查找添加条件。例如，`Client.where("orders_count = '2'")` 会查找所有 `orders_count` 字段的值为 2 的客户记录。

WARNING: 使用纯字符串创建条件存在容易受到 SQL 注入攻击的风险。例如，`Client.where("first_name LIKE '%#{params[:first_name]}%'")` 是不安全的。在下一节中我们会看到，使用数组创建条件是推荐的做法。

[[array-conditions]]
==== 数组条件

如果 `Client.where("orders_count = '2'")` 这个例子中的数字是变化的，比如说是从别处传递过来的参数，那么可以像下面这样进行查找：

[source,ruby]
----
Client.where("orders_count = ?", params[:orders])
----

Active Record 会把第一个参数作为条件字符串，并用之后的其他参数来替换条件字符串中的问号（`?`）。

我们还可以指定多个条件：

[source,ruby]
----
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
----

在上面的例子中，第一个问号会被替换为 `params[:orders]` 的值，第二个问号会被替换为 `false` 在 SQL 中对应的值，这个值是什么取决于所使用的数据库适配器。

强烈推荐使用下面这种写法：

[source,ruby]
----
Client.where("orders_count = ?", params[:orders])
----

而不是：

[source,ruby]
----
Client.where("orders_count = #{params[:orders]}")
----

原因是出于参数的安全性考虑。把变量直接放入条件字符串会导致变量原封不动地传递给数据库，这意味着即便是恶意用户提交的变量也不会被转义。这样一来，整个数据库就处于风险之中，因为一旦恶意用户发现自己能够滥用数据库，他就可能做任何事情。所以，永远不要把参数直接放入条件字符串。

NOTE: 关于 SQL 注入的危险性的更多介绍，请参阅 <<security#sql-injection>>。

[[placeholder-conditions]]
===== 条件中的占位符

和问号占位符（`?`）类似，我们还可以在条件字符串中使用符号占位符，并通过 Hash 来提供符号对应的值：

[source,ruby]
----
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
----

如果条件中有很多变量，那么上面这种写法的可读更好。

[[hash-conditions]]
==== Hash 条件

Active Record 还允许使用 Hash 条件，以提高条件语句的可读性。在使用 Hash 条件时，Hash 的键用于说明需要限制的字段，Hash 的值用于说明如何进行限制。

NOTE: 在 Hash 条件中，只能进行等式、范围和子集检查。

[[equality-conditions]]
===== 等式条件

[source,ruby]
----
Client.where(locked: true)
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM clients WHERE (clients.locked = 1)
----

其中字段名也可以是字符串：

[source,ruby]
----
Client.where('locked' => true)
----

对于 `belongs_to` 关联的情况，如果使用 Active Record 对象作为值，就可以使用关联键来指定模型。这种方法也适用于多态关联。

[source,ruby]
----
Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
----

NOTE: 等式条件中的值不能是符号。例如，`Client.where(status: :active)` 这种写法是错误的。

[[range-conditions]]
===== 范围条件

[source,ruby]
----
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
----

上面的代码会使用 `BETWEEN` SQL 表达式·查找所有昨天创建的客户记录：

[source,sql]
----
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
----

这是 <<active_record_querying.#array-conditions>> 中示例代码的更简短的写法。

[[subset-conditions]]
===== 子集条件

要想用 `IN` 表达式来查找记录，可以在 Hash 条件中使用数组：

[source,ruby]
----
Client.where(orders_count: [1,3,5])
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
----

[[not-conditions]]
==== NOT 条件

可以用 `where.not` 创建 `NOT` SQL 查询：

[source,ruby]
----
Client.where.not(locked: true)
----

也就是说，先调用没有参数的 `where` 方法，然后马上链式调用 `not` 方法，就可以生成这个查询。上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM clients WHERE (clients.locked != 1)
----

[[ordering]]
=== 排序

要想按特定顺序从数据库取回记录，可以使用 `order` 方法。

例如，如果想按 `created_at` 字段的升序方式取回记录：

[source,ruby]
----
Client.order(:created_at)
# OR
Client.order("created_at")
----

还可以使用 `ASC`（升序） 或 `DESC`（降序） 指定排序方式：

[source,ruby]
----
Client.order(created_at: :desc)
# OR
Client.order(created_at: :asc)
# OR
Client.order("created_at DESC")
# OR
Client.order("created_at ASC")
----

或按多个字段排序：

[source,ruby]
----
Client.order(orders_count: :asc, created_at: :desc)
# OR
Client.order(:orders_count, created_at: :desc)
# OR
Client.order("orders_count ASC, created_at DESC")
# OR
Client.order("orders_count ASC", "created_at DESC")
----

如果多次调用 `order` 方法，后续排序会在第一次排序的基础上进行：

[source,sql]
----
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
----

[[selecting-specific-fields]]
=== 选择特定字段

`Model.find` 方法默认使用 `select *` 从结果集中选择所有字段。

可以使用 `select` 方法从结果集中选择字段的子集。

例如，只选择 `viewable_by` 和 `locked` 字段：

[source,ruby]
----
Client.select("viewable_by, locked")
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT viewable_by, locked FROM clients
----

请注意，上面的代码初始化的模型对象只包含了所选择的字段，这时如果访问这个模型对象未包含的字段就会引发异常：

----
ActiveModel::MissingAttributeError: missing attribute: <attribute>
----

其中 `<attribute>` 是我们想要访问的字段。`id` 方法不会引发 `ActiveRecord::MissingAttributeError` 异常，因此在使用关联时一定要小心，因为只有当 `id` 方法正常工作时关联才能正常工作。

在查询时如果想让某个字段的同值记录只出现一次，可以使用 `distinct` 方法添加唯一性约束：

[source,ruby]
----
Client.select(:name).distinct
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT DISTINCT name FROM clients
----

唯一性约束在添加之后还可以删除：

[source,ruby]
----
query = Client.select(:name).distinct
# => Returns unique names

query.distinct(false)
# => Returns all names, even if there are duplicates
----

[[limit-and-offset]]
=== 限量和偏移量

要想在 `Model.find` 方法生成的 SQL 语句中使用 `LIMIT` 子句，可以在关联上使用 `limit` 和 `offset` 方法。

`limit` 方法用于说明想要取回的记录的数量，`offset` 方法用于说明取回记录时在第一条记录之前要跳过多少条记录。例如：

[source,ruby]
----
Client.limit(5)
----

上面的代码会返回 5 条客户记录，因为没有使用 `offset` 方法，所以返回的这 5 条记录就是前 5 条记录。代码生成的 SQL 语句如下：

[source,sql]
----
SELECT * FROM clients LIMIT 5
----

如果使用 `offset` 方法：

[source,ruby]
----
Client.limit(5).offset(30)
----

这时会返回从第 31 条记录开始的 5 条记录。代码生成的 SQL 语句如下：

[source,sql]
----
SELECT * FROM clients LIMIT 5 OFFSET 30
----

[[group]]
=== 分组

要想在查找器生成的 SQL 语句中使用 `GROUP BY` 子句，可以使用 `group` 方法。

例如，如果我们想根据订单创建日期取回订单记录：

[source,ruby]
----
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
----

上面的代码会为数据库中同一天创建的订单创建 `Order` 对象。代码生成的 SQL 语句如下：

[source,sql]
----
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
----

[[total-of-grouped-items]]
==== 分组项目的总数

要想得到一次查询中分组项目的总数，可以在调用 `group` 方法后调用 `count` 方法。

[source,ruby]
----
Order.group(:status).count
# => { 'awaiting_approval' => 7, 'paid' => 12 }
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
----

[[having]]
=== `having` 方法

SQL 语句用 `HAVING` 子句来说明 `GROUP BY` 字段的约束条件。要想在 `Model.find` 方法生成的 SQL 语句中使用 `HAVING` 子句，可以使用 `having` 方法。例如：

[source,ruby]
----
Order.select("date(created_at) as ordered_date, sum(price) as total_price").
  group("date(created_at)").having("sum(price) > ?", 100)
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) > 100
----

上面的查询会返回每个 `Order` 对象的日期和总价，查询结果按日期分组并排序，并且总价必须高于 100。

[[overriding-conditions]]
=== 条件覆盖

[[unscope]]
==== `unscope` 方法

可以使用 `unscope` 方法删除某些条件。 例如：

[source,ruby]
----
Article.where('id > 10').limit(20).order('id asc').unscope(:order)
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM articles WHERE id > 10 LIMIT 20

# Original query without `unscope`
SELECT * FROM articles WHERE id > 10 ORDER BY id asc LIMIT 20
----

还可以使用 `unscope` 方法删除 `where` 方法中的某些条件。例如：

[source,ruby]
----
Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0
----

在关联中使用 `unscope` 方法，会对整个关联造成影响：

[source,ruby]
----
Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"
----

[[only]]
==== `only` 方法

可以使用 `only` 方法覆盖某些条件。例如：

[source,ruby]
----
Article.where('id > 10').limit(20).order('id desc').only(:order, :where)
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC

# Original query without `only`
SELECT "articles".* FROM "articles" WHERE (id > 10) ORDER BY id desc LIMIT 20
----

[[reorder]]
==== `reorder` 方法

可以使用 `reorder` 方法覆盖默认作用域中的 `order` 方法。例如：

[source,ruby]
----
class Article < ApplicationRecord
  has_many :comments, -> { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
----

如果不使用 `reorder` 方法，那么会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM articles WHERE id = 10
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
----

[[reverse-order]]
==== `reverse_order` 方法

可以使用 `reverse_order` 方法反转 `order` 方法的条件。

[source,sql]
----
Client.where("orders_count > 10").order(:name).reverse_order
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
----

如果查询时没有使用 `order` 方法，那么 `reverse_order` 方法会使查询结果按主键的降序方式排序。

[source,ruby]
----
Client.where("orders_count > 10").reverse_order
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC
----

`reverse_order` 方法不接受任何参数。

[[rewhere]]
==== `rewhere` 方法

可以使用 `rewhere` 方法覆盖 `where` 方法中的具名条件。例如：

[source,ruby]
----
Article.where(trashed: true).rewhere(trashed: false)
----

上面的代码会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM articles WHERE `trashed` = 0
----

如果不使用 `rewhere` 方法而是再次使用 `where` 方法：

[source,sql]
----
Article.where(trashed: true).where(trashed: false)
----

会生成下面的 SQL 语句：

[source,sql]
----
SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
----

[[null-relation]]
=== 空关联

`none` 方法返回可以在链式调用中使用的、不包含任何记录的空关联。在这个空关联上应用后续条件链，会继续生成空关联。对于可能返回零结果、但又需要在链式调用中使用的方法或范围，可以使用 `none` 方法来提供返回值。

[source,ruby]
----
Article.none # returns an empty Relation and fires no queries.
----

[source,ruby]
----
# The visible_articles method below is expected to return a Relation.
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # => returning [] or nil breaks the caller code in this case
  end
end
----

[[readonly-objects]]
=== 只读对象

在关联中使用 Active Record 提供的 `readonly` 方法，可以显式禁止修改任何返回对象。如果尝试修改只读对象，不但不会成功，还会引发 `ActiveRecord::ReadOnlyRecord` 异常。

[source,ruby]
----
client = Client.readonly.first
client.visits += 1
client.save
----

在上面的代码中，`client` 被显式设置为只读对象，因此在更新 `client.visits` 的值后调用 `client.save` 就会引发 `ActiveRecord::ReadOnlyRecord` 异常。

[[locking-records-for-update]]
=== 在更新时锁定记录

在数据库中，锁定用于避免更新记录时的条件竞争并确保原子更新。

Active Record 提供了两种锁定机制：

* 乐观锁定
* 悲观锁定

[[optimistic-locking]]
==== 乐观锁定

乐观锁定允许多个用户访问并编辑同一记录，并假设数据发生冲突的可能性最小。其原理是检查读取记录后是否有其他进程尝试更新记录，如果有就引发 `ActiveRecord::StaleObjectError` 异常并忽略该更新。

[[optimistic-locking-column]]
===== 字段的乐观锁定

为了使用乐观锁定，数据表中需要有一个整数类型的 `lock_version` 字段。每次更新记录时，Active Record 都会增加 `lock_version` 字段的值。如果更新请求中 `lock_version` 字段的值比当前数据库中 `lock_version` 字段的值小，更新请求就会失败并引发 `ActiveRecord::StaleObjectError` 异常。例如：

[source,ruby]
----
c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # Raises an ActiveRecord::StaleObjectError
----

在引发异常后，我们需要救援异常并处理冲突，或回滚，或合并，或应用其他业务逻辑来解决冲突。

通过设置 `ActiveRecord::Base.lock_optimistically = false` 可以关闭乐观锁定。

可以使用 `ActiveRecord::Base` 提供的 `locking_column` 类属性来覆盖 `lock_version` 字段名：

[source,ruby]
----
class Client < ApplicationRecord
  self.locking_column = :lock_client_column
end
----

[[pessimistic-locking]]
==== 悲观锁定

悲观锁定使用底层数据库提供的锁定机制。在创建关联时使用 `lock` 方法，会在选定字段上生成互斥锁。使用 `lock` 方法的关联通常被包装在事务中，以避免发生死锁。例如：

[source,ruby]
----
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end
----

对于 MySQL 后端，上面的会话会生成下面的 SQL 语句：

[source,sql]
----
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
----

要想支持其他锁定类型，可以直接传递 SQL 给 `lock` 方法。例如，MySQL 的 `LOCK IN SHARE MODE` 表达式在锁定记录时允许其他查询读取记录，这个表达式可以用作锁定选项：

[source,ruby]
----
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end
----

对于已有模型实例，可以启动事务并一次性获取锁：

[source,ruby]
----
item = Item.first
item.with_lock do
  # This block is called within a transaction,
  # item is already locked.
  item.increment!(:views)
end
----

[[joining-tables]]
=== 连接数据表
